# Базовое решение Fast Codesearch

## Задача:
Хранить индекс файлов. Количество файлов не ограничено.
Искать регулярные выражения с помощтю индекса.

Хранение индекса. Надо уметь:
- Добавлять файлы в индекс
- Обновлять индекс определенного файла
- Удалять файл из индекса
- Полностью удалять существующий индекс

Поиск по индексу. Надо уметь:
- Определять в каких файлах содержится переданная регулярка 
- Искать регулярные выражения в выбранных файлах

## Решение:

#### Хранение индекса
Т.к количество файлов неограничено, мы будем хранить несколько индексов. 
Каждый индекс по сути является шардом.
Изначально предлагаю хранить на одном шарде 100000(далее *MAX_FILES*) фалйов.
Далее эту константу можно будет поправить, исходя из оптимальности.
**Один файл хранится строго на одном шарде**.

Чтобы работать с шардами мы будем хранить мета информацию о них - связь file -> shard,
текущее количество шардов и количество файлов на шардах.

```
class Shard {
   private:
       std::unordered_map<std::string, int> shard;
       int shards_cnt = 1;
       std::vector<int> files_cnt_on_shrads = {0};
   };
``` 

Также при работе с файлами нам надо их как-то нумеровать.
Идентифицировать файлы по их путям - это неудобно и не очень оптимально.
Нам нужно как-то для каждого файла уметь получить новый идентификатор и хранить его.
Для этого предлагаю на каждом шарде хранить unordered_set c числами от 1 до *MAX_FILES*.
Когда хотим получить id для нового файла - берем оттуда любое число, сохраняем в мапку path -> id, и удалем его из этого unordered_set.
Когда хотим удалить файл из индекса - после удаления данных о триграммах, надо удалить связь path -> id и добавить освободившийся id в unordered_set.
Таким образом мы быстро можем получить id файла или удалить его.
Также нам понадобится обратная связь id -> path, чтобы мы могли делать поиск по самому файлу. Логика работы с этой мапкой идентичная.


Данные о триграммах предлагаю хранить в unordered_map trigram -> unordered_set(files_ids).


Тогда:
- для добавления нового файла надо пройтись по всем триграммам файла и добавить эти связи.
- для удаления файла из индекса надо пройтись по всем связям и удалить file_id данного файла из unordered_set
- для обновления индекса файла надо сначала удалить этот файл, а потом его добавить
- для полного удаления индекса надо полностью удалить всю структуру 

#### Поиск по индексу

Чтобы с помощью индекса определить в каких файлах содержится входящая регулярка, надо с помощью алгоритма,
описанного в статье [Regular Expression Matching with a Trigram Index](https://swtch.com/~rsc/regexp/regexp4.html),
получить id файлов, в которых содержится это выражение, а потом в этих файлах сделать полный поиск по этому
выражению с помощью библиотек RE2 или Hyperscan.

Хранение индекса:
```
class Index {
private:
    std::unordered_map<std::string, std::unordered_set<int>> index;
    std::unordered_map<std::string, int> path_to_id;
    std::unordered_map<int, std::string> id_to_path;
};

```